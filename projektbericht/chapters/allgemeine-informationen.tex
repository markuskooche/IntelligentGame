Bei umfangreicheren Softwareprojekten kann nicht einfach drauflos programmiert werden, hier ist es wichtig eine gute Kommunikation untereinander zu gew\"ahrleisten, um sich gegenseitig zu helfen und Informationen auszutauschen.
F\"ur eine erfolgreiche Kommunikation geh\"ort nicht nur eine gewisse technische Grundausstattung, sondern auch ein gutes soziales Miteinander aller Teamkollegen.
In diesem Abschnitt werden alle Teammitglieder sowie die verwendete Software und Hardware vorgestellt.
Durch die Vorstellung ist es f\"ur den Leser eventuell besser nachvollziehbar, wieso das Team eine gewisse Entscheidung getroffen hat.

\subsection{Team und Kommunikation}\label{subsec:team-und-kommunikation}
Alle Teammitglieder studieren Allgemeine Informatik und befinden sich aktuell im vierten Semester.
Wir haben alle gemeinsam das Studium begonnen und kennen uns deshalb bereits seit dem ersten Semester.
Das Team hat zuvor gemeinsam zwei allgemeinwissenschaftliche F\"acher belegt, wodurch wir sicher sein konnten, dass sich alle untereinander verstehen und es somit zu keinen gr\"o"seren Auseinandersetzungen kommen wird.
Mithilfe von Signal, Zoom und Discord werden aktuelle Pl\"ane und neue Erkenntnisse geteilt sowie mindestens einmal w\"ochentlich ein Meeting abgehalten, bei dem alle \"Anderungen dem Team vorgestellt werden.
Bei diesem Meeting handelt es sich um eine Art von Code Review, bei dem gegebenenfalls kleine Fehler bzw.\ Unklarheiten aufgesp\"uren werden, um diese dann schnellstm\"oglich zu beseitigen.
Durch diese Vorstellungsrunden erhoffen wir uns einen besseren \"Uberblick \"uber das gesamte Projekt und ein tieferes Verst\"andnis des Programmcodes.
Alle Teammitglieder haben bereits durch die Vorlesungen Programmieren 1 und Programmieren 2 die grunds\"atzlichen Programmierkonzepte und vor allem das objektorientierte Programmieren gelernt, welches in diesem Projekt von gro"ser Bedeutung ist.
Alle Beteiligten belegten zudem im letzten Semester das Fach Algorithmen \& Datenstrukturen in dem jeder einen umfangreichen \"Uberblick \"uber g\"angige Sortier- und Suchalgorithmen erhalten hat.
Dank diesem Fach ist es f\"ur alle Entwickler wesentlich leichter unterschiedliche performancerelevante Stellen aufzusp\"uren und diese mithilfe von gelernten Algorithmen weiter zu optimieren, um eine bestm\"ogliche Geschwindigkeit herauszuholen.
Das Team hat sich darauf geeinigt alle Klassennamen, Variablen sowie Kommentare und Dokumentationen auf Englisch zu schreiben, da es sich hierbei um die Sprache der Softwareentwicklung handelt.
Benedikt Halbritter hat vor seinem Studium eine schulische Ausbildung als Informatiker abgeschlossen und konnte aus diesem Grund gelernte Inhalte seine Erfahrungen an das Team weitergeben, was sich des\"ofteren sehr positiv herrausstellt.
Iwan Eckert befindet sich in einem dualen Studium, seine beruflichen Erfahrungen brachten dem Team vor allem in der Konfiguration des Build-Tools enorme Zeitersparnisse, sowie Performanzoptimierungen aufgrund von Umstellungen auf andere Softwarekomponenten.
Markus Koch bringt bereits Erfahrungen in LaTeX mit, wodurch er den Teamkollegen bei der Einrichtung der ben\"otigten Software hilft.
Zudem \"ubernimmt er die Aufteilung des gesamten Dokumentes um die \"Ubersichtlichkeit zu verbessern.

Die Vorlesung findet immer dienstags statt.
Im Anschluss setzt sich das Team immer zusammen, um das neue \"Ubungsblatt durchzulesen und eine gerechte Arbeitsverteilung zu finden.
Hier wird ein Konzept der einzelnen Vorgehensweisen erstellt und zudem an einem konzeptionellen Klassendiagramm gearbeitet, damit jedem die Schnittstellen bekannt sind und somit ohne gro"se weitere Absprachen an seinen Aufgaben arbeiten kann.
In der nachfolgenden Tabelle sind alle zu erledigenden Aufgaben mit den entsprechenden Bearbeitern eingetragen.

%\newpage

\vspace{1em}
\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Aufgabe} & \textbf{Entwickler} \\
        \hline
        1.5 & Benedikt, Iwan, Markus \\
        \hline
        2.1 & Benedikt, Iwan, Markus \\
        \hline
        2.2 & Benedikt, Iwan, Markus \\
        \hline
        2.3 & Iwan, Markus \\
        \hline
        3.1 & Benedikt \\
        \hline
        3.2 & Iwan \\
        \hline
        3.3 & Markus \\
        \hline
        4.1 & Iwan, Markus \\
        \hline
        4.2 & Markus \\
        \hline
        4.3 & Benedikt \\
        \hline
        5.1 & .. \\
        \hline
        5.2 & .. \\
        \hline
        6.1 & .. \\
        \hline
        6.2 & .. \\
        \hline
        7.1 & .. \\
        \hline
        7.2 & .. \\
        \hline
        8.1 & .. \\
        \hline
        8.2 & .. \\
        \hline
        9.1 & .. \\
        \hline
        9.2 & .. \\
        \hline
    \end{tabular}
    \caption{Ãœbersicht der Aufgabenverteilung}
    \label{tab:arbeitsverteilung}
\end{table}

\newpage

\subsection{Technische Daten}\label{subsec:technische-daten}
Als Entwicklungsumgebung wurde von allen Teamkollegen das Programm IntelliJ von JetBrains in der Version 2020.3.3 verwendet.
Diese IDE bietet viele n\"utzliche Zusatzfunktionen und beeinhaltet dabei eine integrierte Entwicklungsm\"oglichkeit mittels dieser man LaTeX Dokumente erstellen kann.
Das Programm eignet sich aus diesen Gr\"unden hervorragend f\"ur die Entwicklung umfangreicher Projekte und steht Studenten zus\"atzlich auch in der kommerziellen Version kostenlos zur Verf\"ugung.
Dadurch, dass alle Teammitglieder die gleiche IDE verwenden erhoffen wir uns weniger Kompatibilit\"atsprobleme bei der Entwicklung zu haben und sich zudem gegenseitig bei Fragen zur IDE besser unterst\"utzen zu k\"onnen.
Benedikt und Iwan verwenden als Betriebssystem Windows 10, Markus entwickelt auf macOS 11.
Auf allen Systemen wird zur Versionskontrolle Git in der Version 2.31.1 eingesetzt.
Auf das empfohlene Tool TortoiseGit wurde aufgrund der hervorragenden Integration seitens JetBrains meist verzichtet.
Zum Erstellen von automatisch generierten lauff\"ahigen Programmen setzt unsere Gruppe auf Gradle 6.3.
Bei dieser Version handelt es sich bewusst um eine veraltete jedoch stabile Version, da hierf\"ur bei Problemen mehr Informationen als bei der neusten Version 7.0 zur Verf\"ugung stehen und wir uns daraus insbesondere erhoffen, dass weniger Kompatibili\"atsprobleme auftreten.
Es handelt sich hier um ein einfach zu benutzendes Build-Tool was auf eine eigene Sprache namens Groovy setzt und dadurch gewisse Leistungsvorteile gegen\"uber dem weit bekannten aber veralteten Tool Maven hat.
Das Team entschied sich das Projekt mit der Programmiersprache Java umzusetzen, da diese die gelernte Sprache aus Programmieren 2 ist und somit alle Beteiligten bereits umfangreiche Erfahrungen damit gesammelt haben und sich somit nicht erst in eine andere Programmiersprache einarbeiten m\"ussen.
Zum automatischen Testen unserer Softwarekomponenten benutzen wir au"serdem das JUnit-Testframework, da wir damit alle bereits Erfahrungen gesammelt haben und es sich hierbei um ein weit verbreitetes Framework zum Testen unter Java handelt.

Die Hardware, die zur Entwicklung und zum Durchf\"uhren von Tests eingesetzt wird, sind im Anschluss detailliert aufgef\"uhrt.
Aus Testzwecken wird zudem in einer virtuellen Maschine mit Ubuntu 20.04 LTS getestet, ob das Programm erfolgreich gebaut werden kann.

\newpage

\begin{itemize}
    \item Benedikt Halbritter
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 7490K
        \item Arbeitsspeicher: 16 GB 2800 MHz DDR4
        \item Grafikkarte: NVIDIA GeForce GTX 1070 Ti
        \item Festplatte: SSD 1TB - M.2
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Iwan Eckert
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 4790K
        \item Arbeitsspeicher: 8 GB 1866 MHz DDR3
        \item Grafikkarte: NVIDIA GeForce GTX 780 Ti
        \item Festplatte: SSD 512 GB - SATA III
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Markus Koch
    \begin{itemize}
        \item Prozessor: 2,6 GHz 6-Core Intel Core i7
        \item Arbeitsspeicher: 32 GB 2400 MHz DDR4
        \item Grafikkarte: Radeon Pro 560X 4 GB
        \item Festplatte: APPLE SSD 512GB - PCI-Express
        \item Betriebssystem: macOS 11.2.3
    \end{itemize}
\end{itemize}

\newpage

\subsection{Datenstruktur}\label{subsec:datenstruktur}
Das Spielfeld wird in der Board-Klasse in einem zweidimensionalen char-Array gespeichert.
Wir haben uns f\"ur ein Array anstatt einer Liste entschieden, da sich die Gr\"o"se des Spielfeldes w\"ahrend des gesamten Spielverlaufes nicht mehr \"andert und man so mit konstanter Zeit auf ein bestimmtes Feld zugreifen kann.
Da uns der Server die Informationen \"uber die Map als hexadezimalen Byte-Stream \"ubermittelt, speichern wir diese als char ab um einen m\"oglichst geringen Speicheraufwand von einem Byte zu erzielen.
Die Verwendung eines Strings w\"urde im Gegensatz ganze 4 Byte pro Feld belegen.

Zus\"atzlich werden in der Board-Klasse alle m\"oglichen Spielz\"uge eines Spielers berechnet und ausgew\"ahlte Spielz\"uge durchgef\"uhrt und damit das Spielfeld aktualisiert.
Hierbei wird ein Spielzug durch die Klasse Move repr\"asentiert, welche s\"amtliche Felder beinhaltet die beim Ausf\"uhren des Spielzuges umgef\"arbt werden m\"ussen.
Au"serdem beinhaltet die Klasse die Information dar\"uber, ob es sich bei dem Spielzug um ein Bonus-, Inversions-, Expansions- oder Choicefeld handelt.
Desweiteren speichert die Board-Klasse die Spieleranzahl, den Bombenradius und eine Liste aller Transitionen ab. \\
Transitionen werden in einer HashMap gespeichert, um einen konstant schnellen Abruf zu gew\"ahrleisten zu k\"onnen.
Der Key in der HashMap ist ein Integer, welcher sich wie folgt zusammenstellt:
\begin{align}
    HashKey &=& x \cdot 1000 + y \cdot 10 + r \\
    21.174 &=& 21 \cdot 1000 + 17 \cdot 10 + 4
\end{align}
Befindet sich nun eine Transition an der Position x = 21 und y = 17 in Richtung 4 (nach unten), so lautet der dazugeh\"orige Key 21174, wie er auch in Zeile 2 berechnet wird.
Die Kombination aus Koordinaten und der jeweiligen Richtung ist mit dieser Berechnung immer eindeutig, wodurch die Singularit\"at des Schl\"ussels gew\"ahrleistet werden kann.
Als Value wird der HashMap ein Objekt der Klasse Transition \"ubergeben.
Eine Transition besteht aus einer x1, y1, x2 und einer y2 Koordinate sowie den Richtungen r1 und r2.
Hiermit kann die komplette Transition abgefragt werden und somit den Methoden genau mitgeteilt werden an welcher Stelle und in welcher Richtung ein gewisser Zug auf dem Spielfeld transferiert wird.

S\"amtliche Informationen, wie die Anzahl an Bomben, \"Uberschreibsteinen und die Spielernummer werden in einer Player-Klasse abgespeichert.
Diese Werte m\"ussen f\"ur jeden Spieler unabh\"angig voneinander gespeichert werden.
Zudem kann dort ein disqualifizierter Spieler markiert werden.

Die Player- und Board-Klasse wird von einer \"ubergeordneten Klasse Game koordiniert, welche s\"amtliche Spielabl\"aufe steuert.


\bigskip
\newpage