Bei umfangreicheren Softwareprojekten ist eine umfassende Vorbereitung und Planung unabdingbar.
Es ist wichtig eine gute Kommunikation untereinander zu gew\"ahrleisten, um sich gegenseitig zu helfen und Informationen auszutauschen.
Eine erfolgreiche Kommunikation ben\"otigt nicht nur eine gewisse technische Grundausstattung, sondern auch ein gutes soziales Miteinander aller Teamkollegen.
In diesem Abschnitt werden alle Teammitglieder sowie die verwendete Software und Hardware vorgestellt.
Durch die Vorstellung ist es f\"ur den Leser nachvollziehbarer wie die Entscheidungen im Team herbeigef\"uhrt wurden.

\subsection{Team und Kommunikation}\label{subsec:team-und-kommunikation}
Alle Teammitglieder studieren Allgemeine Informatik, kennen sich seit dem Erstsemester und befinden sich aktuell im vierten Semester.
Das Team belegte gemeinsam zwei allgemeinwissenschaftliche F\"acher, wodurch sich alle noch n\"aher kennenlernen konnte und sich viele Gemeinsamkeiten herausgestellt haben.
Mithilfe von Signal, Zoom und Discord werden aktuelle Pl\"ane und neue Erkenntnisse geteilt sowie mindestens einmal w\"ochentlich ein Meeting abgehalten, bei dem alle \"Anderungen dem Team vorgestellt werden.
Bei diesem Meeting handelt es sich um eine Art von Code Review, bei dem gegebenenfalls kleine Fehler bzw.\ Unklarheiten aufgesp\"urt werden, um diese dann schnellstm\"oglich zu beseitigen.
Durch diese Vorstellungsrunden erhoffen wir uns einen besseren \"Uberblick \"uber das gesamte Projekt und ein tieferes Verst\"andnis des Programmcodes.
Alle Teammitglieder haben bereits durch die Vorlesungen Programmieren 1 und Programmieren 2 die grunds\"atzlichen Programmierkonzepte und vor allem das objektorientierte Programmieren gelernt, welches in diesem Projekt von gro"ser Bedeutung ist.
Alle Beteiligten belegten zudem im letzten Semester das Fach Algorithmen \& Datenstrukturen, in dem jeder einen umfangreichen \"Uberblick \"uber g\"angige Sortier- und Suchalgorithmen erhalten hat.
Dank dieses Fachs ist es f\"ur alle Entwickler wesentlich leichter unterschiedliche performancerelevante Stellen aufzusp\"uren und diese mithilfe von gelernten Algorithmen weiter zu optimieren, um eine bestm\"ogliche Geschwindigkeit herauszuholen.
Das Team hat sich darauf geeinigt alle Klassennamen, Variablen sowie Kommentare und Dokumentationen auf Englisch zu schreiben, da es sich hierbei um die Sprache der Softwareentwicklung handelt.
Benedikt Halbritter hat vor seinem Studium eine schulische Ausbildung als Informatiker abgeschlossen und kann aus diesem Grund gelernte Inhalte an das Team weitergeben, was sich des \"Ofteren als sehr positiv herrausstellt.
Iwan Eckert befindet sich in einem dualen Studium, seine beruflichen Erfahrungen bringen dem Team vor allem in der Konfiguration des Build-Tools enorme Zeitersparnisse, sowie Performanzoptimierungen aufgrund von Umstellungen auf andere Softwarekomponenten.
Markus Koch verf\"ugt bereits \"uber Erfahrungen in LaTeX, wodurch er den Teamkollegen bei der Einrichtung der ben\"otigten Software hilft.
Zudem \"ubernimmt er die Aufteilung des gesamten Dokumentes um die \"Ubersichtlichkeit zu verbessern.

Die Vorlesung findet immer dienstags statt.
Im Anschluss wird im Team das neue \"Ubungsblatt durchgelesen und eine gerechte Arbeitsteilung durchgef\"uhrt.
Hier wird ein Konzept der einzelnen Vorgehensweisen erstellt und zudem an einem konzeptionellen Klassendiagramm gearbeitet, damit jedem die Schnittstellen bekannt sind und somit jeder ohne gro"se weitere Absprachen an seinen Aufgaben arbeiten kann.
In der nachfolgenden Tabelle sind alle zu erledigenden Aufgaben mit den entsprechenden Bearbeitern eingetragen.

%\newpage

\vspace{1em}
\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Aufgabe} & \textbf{Entwickler} \\
        \hline
        1.5 & Benedikt, Iwan, Markus \\
        \hline
        2.1 & Benedikt, Iwan, Markus \\
        \hline
        2.2 & Benedikt, Iwan, Markus \\
        \hline
        2.3 & Iwan, Markus \\
        \hline
        3.1 & Benedikt \\
        \hline
        3.2 & Iwan \\
        \hline
        3.3 & Markus \\
        \hline
        4.1 & Iwan, Markus \\
        \hline
        4.2 & Markus \\
        \hline
        4.3 & Benedikt \\
        \hline
        5.1 & Iwan \\
        \hline
        6.1 & Iwan \\
        \hline
        6.2 & Markus \\
        \hline
        6.3 & Markus \\
        \hline
        6.4 & Benedikt \\
        \hline
        7.1 & Iwan \\
        \hline
        7.2 & Iwan \\
        \hline
        7.3 & Markus \\
        \hline
        7.4 & Benedikt, Iwan, Markus \\
        \hline
        7.5 & Benedikt, Markus \\
        \hline
        8.1 & .. \\
        \hline
        8.2 & .. \\
        \hline
        9.1 & .. \\
        \hline
        9.2 & .. \\
        \hline
    \end{tabular}
    \caption{Ãœbersicht der Aufgabenverteilung}
    \label{tab:arbeitsverteilung}
\end{table}

\newpage

\subsection{Technische Daten}\label{subsec:technische-daten}
Als Entwicklungsumgebung wurde von allen Teamkollegen das Programm IntelliJ von JetBrains in der Version 2020.3.3 verwendet.
Diese IDE bietet viele n\"utzliche Zusatzfunktionen und beeinhaltet dabei eine integrierte Entwicklungsm\"oglichkeit mittels der man LaTeX Dokumente erstellen kann.
Das Programm eignet sich aus diesen Gr\"unden hervorragend f\"ur die Entwicklung umfangreicher Projekte und steht Studenten zus\"atzlich auch in der kommerziellen Version kostenlos zur Verf\"ugung.
Da alle Teammitglieder die gleiche IDE verwenden, erhoffen wir uns weniger Kompatibilit\"atsprobleme bei der Entwicklung und bessere gegenseitige Unterst\"utzung bei Fragen zur IDE.
Benedikt und Iwan verwenden als Betriebssystem Windows 10, Markus entwickelt auf macOS 11.
Auf allen Systemen wird zur Versionskontrolle Git in der Version 2.31.1 eingesetzt.
Auf das empfohlene Tool TortoiseGit wird aufgrund der hervorragenden Integration seitens JetBrains meist verzichtet.
Zum Erstellen von automatisch generierten lauff\"ahigen Programmen setzt unsere Gruppe auf Gradle 6.3.
Bei dieser Version handelt es sich bewusst um eine veraltete jedoch stabile Version da mehr Informationen als bei der neusten Version 7.0 zur Verf\"ugung stehen und wir auf weniger auftretende Kompatibili\"atsprobleme hoffen.
Es handelt sich hier um ein einfach zu benutzendes Build-Tool, was auf eine eigene Sprache namens Groovy setzt und dadurch gewisse Leistungsvorteile gegen\"uber dem weit bekannten aber veralteten Tool Maven hat.
Das Team entschied sich, das Projekt mit der Programmiersprache Java umzusetzen, da diese die gelernte Sprache aus Programmieren 2 ist und somit alle Beteiligten bereits umfangreiche Erfahrungen damit gesammelt haben und wir uns somit nicht erst in eine andere Programmiersprache einarbeiten m\"ussen.
Zum automatischen Testen unserer Softwarekomponenten benutzen wir au"serdem das JUnit-Testframework, da wir alle bereits damit Erfahrungen gesammelt haben und es sich um ein weit verbreitetes Framework zum Testen unter Java handelt.

Die Hardware, die zur Entwicklung und zum Durchf\"uhren von Tests eingesetzt wird, ist im Anschluss detailliert aufgef\"uhrt.
Aus Testzwecken wird zudem in einer virtuellen Maschine mit Ubuntu 20.04 LTS getestet, ob das Programm erfolgreich gebaut werden kann.

\newpage

\begin{itemize}
    \item Benedikt Halbritter
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 7490K
        \item Arbeitsspeicher: 16 GB 2800 MHz DDR4
        \item Grafikkarte: NVIDIA GeForce GTX 1070 Ti
        \item Festplatte: SSD 1TB - M.2
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Iwan Eckert
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 4790K
        \item Arbeitsspeicher: 8 GB 1866 MHz DDR3
        \item Grafikkarte: NVIDIA GeForce GTX 780 Ti
        \item Festplatte: SSD 512 GB - SATA III
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Markus Koch
    \begin{itemize}
        \item Prozessor: 2,6 GHz 6-Core Intel Core i7
        \item Arbeitsspeicher: 32 GB 2400 MHz DDR4
        \item Grafikkarte: Radeon Pro 560X 4 GB
        \item Festplatte: APPLE SSD 512GB - PCI-Express
        \item Betriebssystem: macOS 11.2.3
    \end{itemize}
\end{itemize}

\newpage

\subsection{Datenstruktur}\label{subsec:datenstruktur}
Das Spielfeld wird in der Board-Klasse in einem zweidimensionalen char-Array gespeichert.
Wir haben uns f\"ur ein Array statt einer Liste entschieden, da sich die Gr\"o"se des Spielfeldes w\"ahrend des gesamten Spielverlaufes nicht mehr \"andert und man so mit konstanter Zeit auf ein bestimmtes Feld zugreifen kann.
Da uns der Server die Informationen \"uber die Map als hexadezimalen Byte-Stream \"ubermittelt, speichern wir diese als char ab um einen m\"oglichst geringen Speicheraufwand von einem Byte zu erzielen.
Die Verwendung eines Strings w\"urde im Gegensatz dazu ganze 4 Byte pro Feld belegen.

Zus\"atzlich werden in der Board-Klasse alle m\"oglichen Spielz\"uge eines Spielers berechnet, ausgew\"ahlte Spielz\"uge durchgef\"uhrt und damit das Spielfeld aktualisiert.
Hierbei wird ein Spielzug durch die Klasse Move repr\"asentiert, welche s\"amtliche Felder beinhaltet, die beim Ausf\"uhren des Spielzuges umgef\"arbt werden m\"ussen.
Au"serdem beinhaltet die Klasse die Information dar\"uber, ob es sich bei dem Spielzug um ein Bonus-, Inversions-, Expansions- oder Choicefeld handelt.
Desweiteren speichert die Board-Klasse die Spieleranzahl, den Bombenradius und eine Liste aller Transitionen ab. \\
Transitionen werden in einer HashMap gespeichert, um einen konstant schnellen Abruf gew\"ahrleisten zu k\"onnen.
Der Key in der HashMap ist ein Integer, welcher sich wie folgt zusammenstellt:
\begin{align}
    HashKey &=& x \cdot 1000 + y \cdot 10 + r \\
    21.174 &=& 21 \cdot 1000 + 17 \cdot 10 + 4
\end{align}
Befindet sich nun eine Transition an der Position x = 21 und y = 17 in Richtung 4 (nach unten), so lautet der dazugeh\"orige Key 21174, wie er auch in Zeile 2 berechnet wird.
Die Kombination aus Koordinaten und der jeweiligen Richtung ist mit dieser Berechnung immer eindeutig, wodurch die Singularit\"at des Schl\"ussels gew\"ahrleistet ist.
Als Value wird der HashMap ein Objekt der Klasse Transition \"ubergeben.
Eine Transition besteht aus einer x1, y1, x2 und einer y2 Koordinate sowie den Richtungen r1 und r2.
Hiermit kann die komplette Transition abgefragt und somit den Methoden genau mitgeteilt werden, an welcher Stelle und in welcher Richtung ein gewisser Zug auf dem Spielfeld transferiert wird.

S\"amtliche Informationen, wie die Anzahl an Bomben, \"Uberschreibsteinen und die Spielernummer werden in einer Player-Klasse abgespeichert.
Diese Werte m\"ussen f\"ur jeden Spieler unabh\"angig voneinander gesichert werden.
Zudem kann dort ein disqualifizierter Spieler markiert werden.

Die Player- und Board-Klasse wird von einer \"ubergeordneten Klasse Game koordiniert, die s\"amtliche Spielabl\"aufe steuert.


\bigskip
\newpage