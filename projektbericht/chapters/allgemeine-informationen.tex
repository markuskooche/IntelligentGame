Bei umfangreicheren Softwareprojekten ist eine umfassende Vorbereitung und Planung unabdingbar.
Es ist wichtig eine gute Kommunikation untereinander zu gew\"ahrleisten, um sich gegenseitig zu helfen und Informationen auszutauschen.
Eine erfolgreiche Kommunikation ben\"otigt nicht nur eine gewisse technische Grundausstattung, sondern auch ein gutes soziales Miteinander aller Teamkollegen.
In diesem Abschnitt werden alle Teammitglieder sowie die verwendete Software und Hardware vorgestellt.
Durch die Vorstellung ist es f\"ur den Leser besser nachvollziehbar wie das Team Entscheidungen herbeigef\"uhrt.

\subsection{Team und Kommunikation}\label{subsec:team-und-kommunikation}
Alle Teammitglieder studieren Allgemeine Informatik, kennen sich seit dem Erstsemester und befinden sich aktuell im vierten Semester.
Das Team belegte gemeinsam zwei allgemeinwissenschaftliche F\"acher, wodurch sich alle noch n\"aher kennengelernt und sich daraus viele Gemeinsamkeiten herausgestellt haben.
Mithilfe von Signal, Zoom und Discord teilt das Team aktuelle Pl\"ane und neue Erkenntnisse.
Zudem wird mindestens einmal w\"ochentlich ein Meeting abgehalten, bei dem jeder Entwickler seine \"Anderungen dem Team vorstellt.
Bei diesem Meeting handelt es sich um eine Art von Code-Review, bei dem gegebenenfalls kleine Fehler bzw.\ Unklarheiten aufgesp\"urt werden, um diese dann schnellstm\"oglich zu beseitigen.
Durch diese Vorstellungsrunden erhoffen sich alle Beteiligten einen besseren \"Uberblick \"uber das gesamte Projekt und ein tieferes Verst\"andnis des Programmcodes.
Alle Teammitglieder haben bereits durch die Vorlesungen Programmieren 1 und Programmieren 2 die grunds\"atzlichen Programmierkonzepte und vor allem das objektorientierte Programmieren kennengelernt, welches in diesem Projekt von gro"ser Bedeutung ist.
Alle Entwickler belegten zudem im letzten Semester das Fach Algorithmen \& Datenstrukturen, in dem jeder einen umfangreichen \"Uberblick \"uber g\"angige Sortier- und Suchalgorithmen erhalten hat.
Dank diesem Modul ist es f\"ur alle Mitwirkende wesentlich leichter unterschiedliche performancerelevante Stellen aufzusp\"uren und diese mithilfe von bekannten Algorithmen weiter zu optimieren, um eine bestm\"ogliche Geschwindigkeit zu erreichen.
Das Team schreibt alle Klassennamen, Variablen sowie Kommentare und Dokumentationen auf Englisch, da es sich hierbei um die Sprache der Softwareentwicklung handelt.

Benedikt Halbritter hat vor seinem Studium eine schulische Ausbildung als Informatiker abgeschlossen und kann aus diesem Grund gelernte Inhalte an das Team weitergeben, was sich des \"Ofteren als sehr positiv herausstellt.
Zudem \"ubernimmt er die Aufgabe, abgeschlossene Spiele zu analysieren und eventuelle schlecht Z\"uge ausfindig zu machen.
Dadurch kann das gesamte Team leichter Karten entdecken, die aktuell nicht hervorragend bespielt werden.
Aus dem oben genannten Grund, testet er auch die Karten auf fehlerhafte Z\"uge und passt zudem die Parameter des Clients an.
Benedikt k\"ummert sich zudem, dass regelm\"a"sig Teambesprechungen stattfinden und teilt den Teammitgliedern die aktuellen Aufgaben der Woche mit.
Iwan Eckert befindet sich in einem dualen Studium, seine beruflichen Erfahrungen bringen dem Team vor allem in der Konfiguration des Build-Tools enorme Zeitersparnisse, sowie Performanzoptimierungen aufgrund von Umstellungen auf andere Softwarekomponenten.
Er versucht zudem eine gerechte Aufgabenverteilung f\"ur alle Beteiligten zu finden und schreibt diese in einen gemeinsamen Kalender.
Des Weiteren \"ubernimmt er die Fehlersuche in der Heuristik sowie deren L\"osungen.
Au"serdem \"uberarbeitet er die Architektur und f\"uhrt gr\"o"sere Refactoring-Aufgaben durch.
Markus Koch verf\"ugt bereits \"uber Erfahrungen in \LaTeX, wodurch er den Teamkollegen bei der Einrichtung der ben\"otigten Software hilft.
Zudem \"ubernimmt er die Aufteilung des gesamten Dokumentes um die \"Ubersichtlichkeit zu verbessern.
Er besitzt erste Kenntnisse in der Illustration von Bildern, weshalb er die Bilder f\"ur den Projektbericht gestaltet.
Unter Anderem \"ubernimmt er auch die Aufgabe, den E-Mail Verkehr zu \"uberwachen und die Teammitglieder \"uber E-Mails zu informieren und diese schnellstm\"oglich zu beantworten.
Au"serdem ist Markus sehr kontaktfreudig, weshalb er mit anderen Teams Gespr\"ache \"uber deren aktuellen Stand f\"uhrt, um sich mit anderen Team besser vergleichen zu k\"onnen.

Die Vorlesung findet immer dienstags statt.
Im Anschluss wird im Team das neue \"Ubungsblatt gepr\"uft und eine gerechte Arbeitsteilung durchgef\"uhrt.
Hier wird ein Konzept der einzelnen Vorgehensweisen erstellt und zudem an einem konzeptionellen Klassendiagramm gearbeitet, damit jedem die Schnittstellen bekannt sind und somit jeder ohne gro"se weitere Absprachen an seinen Aufgaben arbeiten kann.
(Das fertige Klassendiagramm befindet sich im Anhang.)
In der nachfolgenden Tabelle sind alle zu erledigenden Aufgaben mit den entsprechenden Bearbeitern eingetragen.

\newpage

\vspace{1em}
\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Entwickler} & \textbf{Aufgabe} \\
        \hline
        Benedikt, Iwan, Markus & Entwicklung der Datenstruktur\\
        \hline
        Benedikt, Iwan, Markus & Algorithmus zum Finden g\"ultiger Z\"uge \\
        \hline
        Benedikt, Iwan, Markus & Dokumentation einer Zugheuristik \\
        \hline
        Iwan, Markus & Erweitern g\"ultiger Z\"uge Spezialfelder  \\
        \hline
        Benedikt & Verbesserung der Zugheuristik \\
        \hline
        Iwan & Implementierung der Zugheuristik \\
        \hline
        Markus & Erstellen des Projektberichtes (Kapitel 1--3) \\
        \hline
        Iwan, Markus & Implementierung der Netzwerkfunktionalit\"at \\
        \hline
        Markus & Implementierung der Client-Parameter \\
        \hline
        Benedikt & Erstellen des Build-Files \\
        \hline
        Iwan & Implementierung der \texttt{Paranoidsuche} \\
        \hline
        Iwan & Implementierung von \texttt{Alpha-Beta-Pruning} \\
        \hline
        Markus & Erstellen der Statistik f\"ur den Projektbericht \\
        \hline
        Iwan & Implementierung abschaltbarer Zugsortierung \\
        \hline
        Iwan & Implementierung von \texttt{Iterative-Deepening} \\
        \hline
        Benedikt & Implementierung des \texttt{MapAnalyzers} \\
        \hline
        Markus & Implementierung des \texttt{GameAnalyzers} \\
        \hline
        Markus & Erweitern der Client-Parameter \\
        \hline
        Benedikt, Iwan, Markus & Erstellen von Anforderungen an den Fightclub \\
        \hline
        Benedikt, Markus & \"Uberarbeitung des Projektberichtes \\
        \hline
        Benedikt, Markus & Implementierung der Bombenheuristik \\
        \hline
        Iwan & Implementierung von \texttt{BRS}, \texttt{BRS+} und \texttt{Killer Heuristik} \\
        \hline
        Benedikt, Markus & Implementierung von \texttt{Monte-Carlo-Tree-Search} \\
        \hline
        Benedikt & Implementierung einer Spezialfeld-Berechnung \\
        \hline
        Iwan & Implementierung einer \texttt{intelligenten Zugsortierung} \\
        \hline
        Markus & Implementierung eines Heuristik-Controllers \\
        \hline
        Benedikt, Iwan, Markus & \"Uberarbeitung des Projektberichtes \\
        \hline
    \end{tabular}
    \caption{\"Ubersicht der Aufgabenverteilung}
    \label{tab:arbeitsverteilung}
\end{table}
\vspace{1em}

\newpage

\subsection{Technische Daten}\label{subsec:technische-daten}
Als Entwicklungsumgebung wird von allen Teamkollegen das Programm IntelliJ von JetBrains~\cite{intellij} in der Version 2021.1 verwendet.
Diese IDE bietet viele n\"utzliche Zusatzfunktionen, wie z.B.\ das automatische Erstellen von UML-Klassendiagrammen, eine direkt integrierte Versionskontrolle, eine umfassende Code-Vervollst\"andigung und ein profundes Plug-In mittels dessem man unkompliziert \LaTeX\ Dokumente erstellen kann.
Das Programm eignet sich aus diesen Gr\"unden hervorragend f\"ur die Entwicklung umfangreicher Projekte und steht Studenten zus\"atzlich auch in der kommerziellen Version kostenlos zur Verf\"ugung.
Da alle Teammitglieder die gleiche IDE verwenden, erhofft man sich weniger Kompatibilit\"atsprobleme bei der Entwicklung und eine bessere gegenseitige Unterst\"utzung bei Fragen zur IDE.
Benedikt und Iwan verwenden als Betriebssystem Windows 10, Markus entwickelt auf macOS 11.
Auf allen Systemen wird zur Versionskontrolle Git~\cite{git} in der Version 2.31.1 eingesetzt.
Auf das empfohlene Tool TortoiseGit wird aufgrund der hervorragenden Integration seitens JetBrains meist verzichtet.
Zum Erstellen von automatisch generierten lauff\"ahigen Programmen setzt die Gruppe auf Gradle 6.3~\cite{gradle}.
Bei dieser Version handelt es sich bewusst um eine veraltete jedoch stabile Version da mehr Informationen als bei der neusten Version 7.0 zur Verf\"ugung stehen und man sich dadurch zudem weniger auftretende Kompatibili\"atsprobleme erhofft.
Der Hauptunterschied von Gradle zu anderen Build-Systemen besteht in der Konfigurationsdatei.
Gradle setzt hierbei auf Groovy, welches im Gegensatz zu XML wesentlich besser lesbar ist und auch einen \emph{Continuous Mode} besitzt.
Dadurch "[\ldots] kann Gradle \"Anderungen am Quellcode \"uberwachen und automatisch betroffene Artefakte neu bauen." \cite[S. 219 ff.]{besserCoden:gradle}
\ Gradle erkennt somit Quellcode, der sich nicht ge\"andert hat.
Dieser muss anschlie"send nicht neu gebaut werden, wodurch sich eine viel k\"urzere Erstellungszeit ergibt.
Das Projekt ist mit der Programmiersprache Java umgesetzt, da diese die gelernte Sprache aus Programmieren 2 ist und somit alle Beteiligten bereits umfangreiche Erfahrungen damit gesammelt haben und man sich somit nicht erst in eine andere Programmiersprache einarbeiten muss.
Zum automatischen Testen der Softwarekomponenten wird au"serdem das JUnit-Testframework~\cite{junit} in Version 4 benutzt, da alle Teammitglieder bereits damit Erfahrungen gesammelt haben und es sich um ein weit verbreitetes Framework zum Testen unter Java handelt.

Die Hardware, die zur Entwicklung und zum Durchf\"uhren von Tests eingesetzt wird, ist im Anschluss detailliert aufgef\"uhrt.
Aus Testzwecken wird zudem in einer virtuellen Maschine mit Ubuntu 20.04 LTS~\cite{ubuntu} getestet, ob das Programm unter Linux - der Zielplattform des Modules - erfolgreich gebaut werden kann.

\newpage

\begin{itemize}
    \item Benedikt Halbritter
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 7490K
        \item Arbeitsspeicher: 16 GB 2800 MHz DDR4
        \item Grafikkarte: NVIDIA GeForce GTX 1070 Ti
        \item Festplatte: SSD 1TB - M.2
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Iwan Eckert
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 4790K
        \item Arbeitsspeicher: 8 GB 1866 MHz DDR3
        \item Grafikkarte: NVIDIA GeForce GTX 780 Ti
        \item Festplatte: SSD 512 GB - SATA III
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Markus Koch
    \begin{itemize}
        \item Prozessor: 2,6 GHz 6-Core Intel Core i7
        \item Arbeitsspeicher: 32 GB 2400 MHz DDR4
        \item Grafikkarte: Radeon Pro 560X 4 GB
        \item Festplatte: APPLE SSD 512GB - PCI-Express
        \item Betriebssystem: macOS 11.2.3
    \end{itemize}
    \item Labor-PC
    \begin{itemize}
        \item Prozessor: 3,70 GHz 6-Core Intel Core i7-8700K
        \item Arbeitsspeicher: 32 GB 2400 MHz DDR4
        \item Grafikkarte: NVIDIA GeForce RTX 2080
        \item Festplatte: HDD 1TB - SATA III
        \item Betriebssystem: Ubuntu 18.04.1
    \end{itemize}
\end{itemize}
\vspace{1em}

\newpage

\subsection{Datenstruktur}\label{subsec:datenstruktur}
Das Spielfeld wird in der \texttt{Board}-Klasse in einem zweidimensionalen \texttt{char-Array} gespeichert.
Das Team hat sich f\"ur ein Array statt einer Liste entschieden, da sich die Gr\"o"se des Spielfeldes w\"ahrend des gesamten Spielverlaufes nicht mehr \"andert und man so mit konstanter Zeit auf ein bestimmtes Feld zugreifen kann.
Da der Server die Informationen \"uber die Map als hexadezimalen Byte-Stream \"ubermittelt, speichert der Client diese als \texttt{char} ab um einen m\"oglichst geringen Speicheraufwand von einem Byte zu erzielen.
Die Verwendung eines \texttt{Strings} w\"urde im Gegensatz dazu ganze 4 Byte pro Feld belegen.

Zus\"atzlich werden in der \texttt{Board}-Klasse alle m\"oglichen Spielz\"uge eines Spielers berechnet, ausgew\"ahlte Spielz\"uge durchgef\"uhrt und das Spielfeld aktualisiert.
Hierbei wird ein Spielzug durch die Klasse \texttt{Move} repr\"asentiert, welche s\"amtliche Felder beinhaltet, die beim Ausf\"uhren des Spielzuges umgef\"arbt werden m\"ussen.
Au"serdem beinhaltet die Klasse die Information dar\"uber, ob es sich bei dem Spielzug um ein Bonus-, Inversions-, Expansions- oder Choicefeld handelt.
Des Weiteren speichert die \texttt{Board}-Klasse die Spieleranzahl, den Bombenradius und eine Liste aller Transitionen ab. \\
Transitionen werden in einer \texttt{HashMap} gespeichert, um einen konstant schnellen Abruf gew\"ahr\-leisten zu k\"onnen.
Der \texttt{Key} in der \texttt{HashMap} ist ein \texttt{Integer}, welcher sich wie folgt berechnet:
\begin{align}
    \texttt{HashKey} &=& x \cdot 1000 + y \cdot 10 + r \\
    21.174 &=& 21 \cdot 1000 + 17 \cdot 10 + 4
\end{align}
Befindet sich nun eine Transition an der Position $x=21$ und $y=17$ in Richtung $r=4$ (nach unten), so lautet der dazugeh\"orige \texttt{Key} $21.174$, wie er auch in Formel (2) berechnet wird.
Die Kombination aus Koordinaten und der jeweiligen Richtung ist mit dieser Berechnung immer eindeutig, wodurch die Singularit\"at des Schl\"ussels gew\"ahrleistet ist.
Als \texttt{Value} wird der \texttt{HashMap} ein Objekt der Klasse \texttt{Transition} \"ubergeben.
Eine \texttt{Transition} besteht aus einer $x$ und einer $y$ Koordinate sowie der Richtung $r$.
Befindet man sich auf einem Feld und m\"ochte einen Zug in eine Richtung machen, in der sich jedoch kein weiteres Feld befindet, wird anhand dieser Informationen ein \texttt{HashKey} erzeugt und in der \texttt{HashMap} danach gesucht.
Das Ergebnis ist nun ein Objekt der Klasse \texttt{Transition} in der die Position und die Richtung des Feldes enthalten ist, in die ein gewisser Zug auf dem Spielfeld transferiert wird.

S\"amtliche Informationen, wie die Anzahl an Bomben, \"Uberschreibsteine und die Spielernummer werden in einer \texttt{Player}-Klasse abgespeichert.
Diese Werte m\"ussen f\"ur jeden Spieler unabh\"angig voneinander gesichert werden.
Zudem wird dort ein disqualifizierter Spieler markiert.

Die \texttt{Player}- und \texttt{Board}-Klasse wird von einer \"ubergeordneten Klasse \texttt{Game} koordiniert, die s\"amtliche Spielabl\"aufe steuert.


\bigskip
\newpage