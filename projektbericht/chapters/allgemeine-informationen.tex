Bei umfangreicheren Softwareprojekten ist eine umfassende Vorbereitung und Planung unabdingbar.
Es ist wichtig eine gute Kommunikation untereinander zu gew\"ahrleisten, um sich gegenseitig zu helfen und Informationen auszutauschen.
Eine erfolgreiche Kommunikation ben\"otigt nicht nur eine gewisse technische Grundausstattung, sondern auch ein gutes soziales Miteinander aller Teamkollegen.
In diesem Abschnitt werden alle Teammitglieder sowie die verwendete Software und Hardware vorgestellt.
Durch die Vorstellung ist es f\"ur den Leser nachvollziehbarer wie die Entscheidungen im Team herbeigef\"uhrt werden.

\subsection{Team und Kommunikation}\label{subsec:team-und-kommunikation}
Alle Teammitglieder studieren Allgemeine Informatik, kennen sich seit dem Erstsemester und befinden sich aktuell im vierten Semester.
Das Team belegte gemeinsam zwei allgemeinwissenschaftliche F\"acher, wodurch sich alle noch n\"aher kennenlernen konnten und sich daraus viele Gemeinsamkeiten herausgestellt haben.
Mithilfe von Signal, Zoom und Discord werden aktuelle Pl\"ane und neue Erkenntnisse geteilt sowie mindestens einmal w\"ochentlich ein Meeting abgehalten, bei dem alle \"Anderungen dem Team vorgestellt werden.
Bei diesem Meeting handelt es sich um eine Art von Code-Review, bei dem gegebenenfalls kleine Fehler bzw.\ Unklarheiten aufgesp\"urt werden, um diese dann schnellstm\"oglich zu beseitigen.
Durch diese Vorstellungsrunden erhoffen sich alle Beteiligten einen besseren \"Uberblick \"uber das gesamte Projekt und ein tieferes Verst\"andnis des Programmcodes.
Alle Teammitglieder haben bereits durch die Vorlesungen Programmieren 1 und Programmieren 2 die grunds\"atzlichen Programmierkonzepte und vor allem das objektorientierte Programmieren kennengelernt, welches in diesem Projekt von gro"ser Bedeutung ist.
Alle Beteiligten belegten zudem im letzten Semester das Fach Algorithmen \& Datenstrukturen, in dem jeder einen umfangreichen \"Uberblick \"uber g\"angige Sortier- und Suchalgorithmen erhalten hat.
Dank dieses Fachs ist es f\"ur alle Entwickler wesentlich leichter unterschiedliche performancerelevante Stellen aufzusp\"uren und diese mithilfe von bekannten Algorithmen weiter zu optimieren, um eine bestm\"ogliche Geschwindigkeit zu erreichen.
Das Team schreibt alle Klassennamen, Variablen sowie Kommentare und Dokumentationen auf Englisch, da es sich hierbei um die Sprache der Softwareentwicklung handelt.

Benedikt Halbritter hat vor seinem Studium eine schulische Ausbildung als Informatiker abgeschlossen und kann aus diesem Grund gelernte Inhalte an das Team weitergeben, was sich des \"Ofteren als sehr positiv herrausstellt.
Iwan Eckert befindet sich in einem dualen Studium, seine beruflichen Erfahrungen bringen dem Team vor allem in der Konfiguration des Build-Tools enorme Zeitersparnisse, sowie Performanzoptimierungen aufgrund von Umstellungen auf andere Softwarekomponenten.
Markus Koch verf\"ugt bereits \"uber Erfahrungen in LaTeX, wodurch er den Teamkollegen bei der Einrichtung der ben\"otigten Software hilft.
Zudem \"ubernimmt er die Aufteilung des gesamten Dokumentes um die \"Ubersichtlichkeit zu verbessern.

Die Vorlesung findet immer dienstags statt.
Im Anschluss wird im Team das neue \"Ubungsblatt durchgelesen und eine gerechte Arbeitsteilung durchgef\"uhrt.
Hier wird ein Konzept der einzelnen Vorgehensweisen erstellt und zudem an einem konzeptionellen Klassendiagramm gearbeitet, damit jedem die Schnittstellen bekannt sind und somit jeder ohne gro"se weitere Absprachen an seinen Aufgaben arbeiten kann.
In der nachfolgenden Tabelle sind alle zu erledigenden Aufgaben mit den entsprechenden Bearbeitern eingetragen.

\vspace{1em}
\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Entwickler} & \textbf{Aufgabe} \\
        \hline
        Benedikt, Iwan, Markus & Entwicklung der Datenstruktur\\
        \hline
        Benedikt, Iwan, Markus & Algorithmus zum Finden g\"ultiger Z\"uge \\
        \hline
        Benedikt, Iwan, Markus & Dokumentation einer Zugheuristik \\
        \hline
        Iwan, Markus & G\"ultiger Z\"uge erweitern auf Spezialfelder  \\
        \hline
        Benedikt & Verbesserung der Zugheuristik \\
        \hline
        Iwan & Implementierung der Zugheuristik \\
        \hline
        Markus & Erstellen des Projektberichtes (Kapitel 1 - 3) \\
        \hline
        Iwan, Markus & Implementierung der Netzwerkfunktionalit\"at \\
        \hline
        Markus & Implementierung der Client-Parameter \\
        \hline
        Benedikt & Erstellen des Build-Files \\
        \hline
        Iwan & Implementierung der Paranoidsuche \\
        \hline
        Iwan & Implementierung von Alpha-Beta-Pruning \\
        \hline
        Markus & Erstellen der Statistik und eintragen in Projektbericht \\
        \hline
        Benedikt & \"Uberarbeiten des Build-Files \\
        \hline
        Iwan & Implementierung abschaltbarer Zugsortierung \\
        \hline
        Iwan & Implementierung von Iterative-Deepening \\
        \hline
        Benedikt & Implementierung des \texttt{MapAnalyzers} \\
        \hline
        Markus & Implementierung des \texttt{GameAnalyzer}s \\
        \hline
        Markus & Erweitern der Client-Parameter \\
        \hline
        Benedikt, Iwan, Markus & Erstellen von Anforderungen an den Fightclub \\
        \hline
        Benedikt, Markus & \"Uberarbeitung der Projektberichtes \\
        \hline
        Benedikt, Markus & Implementierung der Bombenheuristik \\
        \hline
        9.1 & .. \\
        \hline
        9.2 & .. \\
        \hline
    \end{tabular}
    \caption{Ãœbersicht der Aufgabenverteilung}
    \label{tab:arbeitsverteilung}
\end{table}

\newpage

\subsection{Technische Daten}\label{subsec:technische-daten}
Als Entwicklungsumgebung wird von allen Teamkollegen das Programm IntelliJ von JetBrains in der Version 2021.1 verwendet.
Diese IDE bietet viele n\"utzliche Zusatzfunktionen und beeinhaltet dabei eine integrierte Entwicklungsm\"oglichkeit mittels der man \LaTeX Dokumente erstellen kann.
Das Programm eignet sich aus diesen Gr\"unden hervorragend f\"ur die Entwicklung umfangreicher Projekte und steht Studenten zus\"atzlich auch in der kommerziellen Version kostenlos zur Verf\"ugung.
Da alle Teammitglieder die gleiche IDE verwenden, erhoffen wir uns weniger Kompatibilit\"atsprobleme bei der Entwicklung und bessere gegenseitige Unterst\"utzung bei Fragen zur IDE.
Benedikt und Iwan verwenden als Betriebssystem Windows 10, Markus entwickelt auf macOS 11.
Auf allen Systemen wird zur Versionskontrolle Git in der Version 2.31.1 eingesetzt.
Auf das empfohlene Tool TortoiseGit wird aufgrund der hervorragenden Integration seitens JetBrains meist verzichtet.
Zum Erstellen von automatisch generierten lauff\"ahigen Programmen setzt unsere Gruppe auf Gradle 6.3.
Bei dieser Version handelt es sich bewusst um eine veraltete jedoch stabile Version da mehr Informationen als bei der neusten Version 7.0 zur Verf\"ugung stehen und wir auf weniger auftretende Kompatibili\"atsprobleme hoffen.
Es handelt sich hierbei um ein einfach zu benutzendes Build-Tool, das auf eine eigene Sprache namens Groovy setzt und dadurch gewisse Leistungsvorteile gegen\"uber dem weit bekannten aber veralteten Tool Maven hat.
Das Projekt ist mit der Programmiersprache Java umgesetzen, da diese die gelernte Sprache aus Programmieren 2 ist und somit alle Beteiligten bereits umfangreiche Erfahrungen damit gesammelt haben und man sich somit nicht erst in eine andere Programmiersprache einarbeiten muss.
Zum automatischen Testen der Softwarekomponenten wird au"serdem das JUnit-Testframework in Version 4 benutzt, da alle Teammitglieder bereits damit Erfahrungen gesammelt haben und es sich um ein weit verbreitetes Framework zum Testen unter Java handelt.

Die Hardware, die zur Entwicklung und zum Durchf\"uhren von Tests eingesetzt wird, ist im Anschluss detailliert aufgef\"uhrt.
Aus Testzwecken wird zudem in einer virtuellen Maschine mit Ubuntu 20.04 LTS getestet, ob das Programm unter Linux - der Zielplattform des Modules - erfolgreich gebaut werden kann.

\newpage

\begin{itemize}
    \item Benedikt Halbritter
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 7490K
        \item Arbeitsspeicher: 16 GB 2800 MHz DDR4
        \item Grafikkarte: NVIDIA GeForce GTX 1070 Ti
        \item Festplatte: SSD 1TB - M.2
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Iwan Eckert
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 4790K
        \item Arbeitsspeicher: 8 GB 1866 MHz DDR3
        \item Grafikkarte: NVIDIA GeForce GTX 780 Ti
        \item Festplatte: SSD 512 GB - SATA III
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Markus Koch
    \begin{itemize}
        \item Prozessor: 2,6 GHz 6-Core Intel Core i7
        \item Arbeitsspeicher: 32 GB 2400 MHz DDR4
        \item Grafikkarte: Radeon Pro 560X 4 GB
        \item Festplatte: APPLE SSD 512GB - PCI-Express
        \item Betriebssystem: macOS 11.2.3
    \end{itemize}
    \item Labor-PC
    \begin{itemize}
        \item Prozessor: 3,70 GHz 6-Core Intel Core i7-8700K
        \item Arbeitsspeicher: 32 GB 2400 MHz DDR4
        \item Grafikkarte: NVIDIA GeForce RTX 2080
        \item Festplatte: HDD 1TB - SATA III
        \item Betriebssystem: Ubuntu 18.04.1
    \end{itemize}
\end{itemize}

\newpage

\subsection{Datenstruktur}\label{subsec:datenstruktur}
Das Spielfeld wird in der \texttt{Board}-Klasse in einem zweidimensionalen \texttt{char-Array} gespeichert.
Das Team hat sich f\"ur ein Array statt einer Liste entschieden, da sich die Gr\"o"se des Spielfeldes w\"ahrend des gesamten Spielverlaufes nicht mehr \"andert und man so mit konstanter Zeit auf ein bestimmtes Feld zugreifen kann.
Da der Server die Informationen \"uber die Map als hexadezimalen Byte-Stream \"ubermittelt, speichert der Client diese als \texttt{char} ab um einen m\"oglichst geringen Speicheraufwand von einem Byte zu erzielen.
Die Verwendung eines \texttt{String}s w\"urde im Gegensatz dazu ganze 4 Byte pro Feld belegen.

Zus\"atzlich werden in der \texttt{Board}-Klasse alle m\"oglichen Spielz\"uge eines Spielers berechnet, ausgew\"ahlte Spielz\"uge durchgef\"uhrt und damit das Spielfeld aktualisiert.
Hierbei wird ein Spielzug durch die Klasse \texttt{Move} repr\"asentiert, welche s\"amtliche Felder beinhaltet, die beim Ausf\"uhren des Spielzuges umgef\"arbt werden m\"ussen.
Au"serdem beinhaltet die Klasse die Information dar\"uber, ob es sich bei dem Spielzug um ein Bonus-, Inversions-, Expansions- oder Choicefeld handelt.
Desweiteren speichert die \texttt{Board}-Klasse die Spieleranzahl, den Bombenradius und eine Liste aller Transitionen ab. \\
Transitionen werden in einer \texttt{HashMap} gespeichert, um einen konstant schnellen Abruf gew\"ahr\-leisten zu k\"onnen.
Der \texttt{Key} in der \texttt{HashMap} ist ein \texttt{Integer}, welcher sich wie folgt berechnet:
\begin{align}
    \texttt{HashKey} &=& x \cdot 1000 + y \cdot 10 + r \\
    21.174 &=& 21 \cdot 1000 + 17 \cdot 10 + 4
\end{align}
Befindet sich nun eine Transition an der Position $x=21$ und $y=17$ in Richtung $r=4$ (nach unten), so lautet der dazugeh\"orige \texttt{Key} $21.174$, wie er auch in Formel (2) berechnet wird.
Die Kombination aus Koordinaten und der jeweiligen Richtung ist mit dieser Berechnung immer eindeutig, wodurch die Singularit\"at des Schl\"ussels gew\"ahrleistet ist.
Als \texttt{Value} wird der \texttt{HashMap} ein Objekt der Klasse \texttt{Transition} \"ubergeben.
Eine \texttt{Transition} besteht aus einer $x$ und einer $y$ Koordinate sowie der Richtung $r$.
Befindet man sich auf einem Feld und m\"ochte einen Zug in eine Richtung machen, in der sich jedoch kein weiteres Feld befindet, wird anhand dieser Informationen ein \texttt{HashKey} erzeugt und in der \texttt{HashMap} danach gesucht.
Das Ergebnis ist nun ein Objet der Klasse \texttt{Transition} in der die Position und die Richtung des Feldes enthalten ist, in die ein gewisser Zug auf dem Spielfeld transferiert wird.

S\"amtliche Informationen, wie die Anzahl an Bomben, \"Uberschreibsteinen und die Spielernummer werden in einer \texttt{Player}-Klasse abgespeichert.
Diese Werte m\"ussen f\"ur jeden Spieler unabh\"angig voneinander gesichert werden.
Zudem kann dort ein disqualifizierter Spieler markiert werden.

Die \texttt{Player}- und \texttt{Board}-Klasse wird von einer \"ubergeordneten Klasse \texttt{Game} koordiniert, die s\"amtliche Spielabl\"aufe steuert.


\bigskip
\newpage