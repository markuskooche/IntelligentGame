F\"ur ein gr\"o"seres Softwareprojekt kann nicht einfach drauflos programmiert werden.
Hier ist es wichtig eine gute Kommunikation untereinander zu gew\"ahrleisten um sich gegenseitig zu helfen und Informationen auszutauschen.
F\"ur eine erfolgreiche Kommunikation geh\"ort nicht nur eine gewisse technische Grundausstattung, sondern auch ein gutes soziales Miteinander aller Teamkollegen.
In diesem Abschnitt werden alle Teammitglieder sowie die verwendete Software und Hardware vorgestellt.
Durch die Vorstellung ist es f\"ur den Leser eventuell besser verst\"andlich wieso eine gewisse Entscheidung getroffen wurde.

\subsection{Team und Kommunikation}\label{subsec:team-und-kommunikation}
Alle Teammitglieder studieren Allgemeine Informatik und befinden sich aktuell im vierten Semester.
Wir haben alle gemeinsam das Studium begonnen und kennen und deshalb seit dem ersten Semester.
Das Team hat bereits gemeinsam zwei allgemeinwissenschaftliche F\"acher belegt, wodurch wir sicher sein konnten, dass sich alle untereinander verstehen und es somit zu keinen gr\"o"seren Auseinandersetzungen kommen wird.
Mithilfe von Signal und Discord werden aktuelle Pl\"ane und neue Erkenntnisse geteilt sowie mindestens einmal w\"ochentlich ein Meeting abgehalten bei dem alle \"Anderungen dem Team vorgestellt werden.
Bei diesem Meeting handelt es sich um eine Art von Code Review um gegebenenfalls kleine Fehler bzw.\ Unklarheiten aufzusp\"uren um diese schnellstm\"oglich beseitigen zu k\"onnen.
Durch diese Vorstellungsrunden erhoffen wir uns einen besseren \"Uberblick \"uber das gesamte Projekt und tieferes Verst\"andnis des Programmcodes.
Alle Teammitglieder haben bereits durch die Vorlesungen Programmieren 1 und Programmieren 2 die grunds\"atzlichen Programmierkonzepte und vorallem das objektorientierte Programmieren gelernt, welches in diesem Projekt von gro"ser Bedeutung ist.
Alle Beteiligten belegten zudem im letzten Semester das Fach Algorithmen \& Datenstrukturen in dem jeder einen umfangreichen \"Uberblick \"uber g\"angige Sortier- und Suchalgorithmen erhalten hat.
Dank diesem Fach war es f\"ur alle Entwickler wesentlich leichter unterschiedliche performancerelevante Stellen aufzusp\"uren und diese mithilfe von gelernten Algorithmen weiter zu optimieren, um eine bestm\"ogliche Geschwindigkeit herauszuholen.
Das Team hat sich darauf geeinigt alle Klassennamen, Variablen sowie Kommentare und Dokumentationen auf Englisch zu schreiben, da dies die Sprache in der Softwareentwicklung ist.
Benedikt Halbritter hat vor seinem Studium eine schulische Ausbildung als Informatiker abgeschlossen und konnte aus diesem Grund gelernte Inhalte seine Erfahrungen an das Team weitergeben, was sich des\"ofteren sehr positiv herrausstellte.
Iwan Eckert befindet sich in einem dualen Studium, seine beruflichen Erfahrungen brachten dem Team vor allem in der Konfiguration des Build-Tools sowie Performanzoptimierungen aufgrund von Umstellungen auf andere Softwarekomponenten.
Markus Koch brachte bereits Erfahrungen in LaTeX mit wodurch er den Teamkollegen die bei der Einrichtung der ben\"otigten Software half.
Zudem \"ubernahm der die Aufteilung des gesamten Dokumentes um die \"Ubersichtlichkeit zu verbessern.

Die Vorlesung fand immer dienstags statt.
Im Anschluss hat sich das Team immer zusammengesetzt, um das neue \"Ubungsblatt durchzulesen und eine gerechte Arbeitsverteilung zu finden.
Hier wurde ein Konzept der einzelnen Vorgehensweisen erstellt und zudem an einem konzeptionellen Klassendiagramm gearbeitet, damit jedem die Schnittstellen bekannt waren und somit ohne gro"se weitere Absprachen ein seinen Aufgaben arbeiten konnte.
In der nachfolgenden Tabelle sind alle zu erledigenden Aufgaben mit den entsprechenden Bearbeitern eingetragen.

%\newpage

\vspace{1em}
\begin{table}[!h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Aufgabe} & \textbf{Entwickler} \\
        \hline
        1.5 & Benedikt, Iwan, Markus \\
        \hline
        2.1 & Benedikt, Iwan, Markus \\
        \hline
        2.2 & Benedikt, Iwan, Markus \\
        \hline
        2.3 & Iwan, Markus \\
        \hline
        3.1 & Benedikt \\
        \hline
        3.2 & Iwan \\
        \hline
        3.3 & Markus \\
        \hline
        4.1 & .. \\
        \hline
        4.2 & .. \\
        \hline
        5.1 & .. \\
        \hline
        5.2 & .. \\
        \hline
        6.1 & .. \\
        \hline
        6.2 & .. \\
        \hline
        7.1 & .. \\
        \hline
        7.2 & .. \\
        \hline
        8.1 & .. \\
        \hline
        8.2 & .. \\
        \hline
        9.1 & .. \\
        \hline
        9.2 & .. \\
        \hline
    \end{tabular}
    \caption{Ãœbersicht der Aufgabenverteilung}
    \label{tab:arbeitsverteilung}
\end{table}

\newpage

\subsection{Technische Daten}\label{subsec:technische-daten}
Als Entwicklungsumgebung wurde von allen Teamkollegen das Programm IntelliJ von JetBrains in der Version 2020.3.3 verwendet.
Diese IDE bietet viele n\"utzliche Zusatzfunktionen und beeinhaltet dabei eine intgerierte Entwicklungsm\"oglichkeit mittels dieser man LaTeX Dokumente erstellen kann.
Das Programm eignet sich aus diesen Gr\"unden hervorragend f\"ur die Entwicklung umfangreicher Projekte und steht zus\"atzlich f\"ur Studenten kostenlos zur Verf\"ugung.
Dadurch, dass alle Teammitglieder die gleiche IDE verwenden erhoffen wir uns weniger Kompatibilit\"atsprobleme bei der Entwicklung zu haben.
Benedikt und Iwan verwenden als Betriebssystem Windows 10, Markus entwickelt auf macOS 11.
Auf allen Systemen wird zur Versionskontrolle Git in der Version 2.31.1 verwendet.
Auf das empfohlene Tool Sourcetree wurde aufgrund der hervorragenden Integration seitens JetBrains meist verzichtet.
Zum Erstellen von automatisch generierten lauff\"ahigen Programmen setzt unsere Gruppe auf Gradle 6.3.
Es handelt sich hier um ein einfach zu benutzendes Build-Tool was auf eine eigene Sprache namens Groovy setzt und dadurch gewisse Leistungsvorteile gegen\"uber dem weit bekannten aber veralteten Tool Maven hat.
Das Team entschied sich, Java als Programmiersprache zu verwenden, da das die Sprache aus Programmieren 2 war und somit alle Beteiligten bereits umfangreiche Erfahrungen damit gesammelt hatten und sich somit nicht erst in eine andere Sprache einarbeiten mussten.

Die Hardware, die zur Entwicklung und zum Testen eingesetzt wird, sind im Anschluss detailliert aufgef\"uhrt.
Aus Testzwecken wird zudem in einer virtuellen Maschine mit Ubuntu 20.04 LTS getestet, ob das Programm erfolgreich gebaut werden kann.

\newpage

\begin{itemize}
    \item Benedikt Halbritter
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 7490K
        \item Arbeitsspeicher: 16 GB 2800 MHz DDR4
        \item Grafikkarte: NVIDIA GeForce GTX 1070 Ti
        \item Festplatte: SSD 1TB - M.2
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Iwan Eckert
    \begin{itemize}
        \item Prozessor: Intel Core i7 - 4790K
        \item Arbeitsspeicher: 8 GB 1866 MHz DDR3
        \item Grafikkarte: NVIDIA GeForce GTX 780 Ti
        \item Festplatte: SSD 512 GB - SATA III
        \item Betriebssystem: Windows 10
    \end{itemize}
    \item Markus Koch
    \begin{itemize}
        \item Prozessor: 2,6 GHz 6-Core Intel Core i7
        \item Arbeitsspeicher: 32 GB 2400 MHz DDR4
        \item Grafikkarte: Radeon Pro 560X 4 GB
        \item Festplatte: APPLE SSD 512GB - PCI-Express
        \item Betriebssystem: macOS 11.2.3
    \end{itemize}
\end{itemize}

\newpage

\subsection{Datenstruktur}\label{subsec:datenstruktur}
%Anfangs setzte unser Team auf ein zwei-dimensionales Piece Array.
%Ein Piece Objekt beinhaltete dabei sowohl das aktuelle Element als auch Transitionen.
%Eine gewisse Position speicherte alle Informationen direkt ab.
%Bei dieser Variante entstanden jedoch enorme Performanzprobleme, da man ..
Zur eigentlichen Abspeicherung des Spielfeldes dient ein zwei-dimensionales char-Array, da vom Server die Informationen mittels einer Socketverbindung \"ubertragen werden und somit standardm\"a"sig als char empfangen werden.
Hier ist von Vorteil, dass die Informationen nicht extra in eine andere Form umgewandelt werden m\"ussen und zudem auch kein Performanznachteil geben\"uber Integer entsteht, da ASCII-Symbole von Haus aus als Zahlen abgespeichert werden.
Zudem kann man sich den Overhead sparen der bei der Abspeicherung als String anfallen w\"urde, da ein String 4 Byte einnehmen w\"urde und ein char genau wie ein Integer nur 1 Byte verwendet.
Das Spielfeld befindet sich in einer Board-Klasse, in der zudem Spielz\"uge berechnet und ausgef\"uhrt werden k\"onnen.
Zudem wird hier der Bombenradius abgespeichert, da dieser f\"ur alle Spieler gleich ist.
Jeder Spieler wird in einer Player-Klasse abgespeichert in der die Spielerzahl, sowie die Anzahl an \"Uberschreibsteinen und Bomben abgespeichert werden.
Im weiter Spielverlauf k\"onnen den einzelnen Spielern \"Uberschreibsteine bzw.\ Bomben gutgeschrieben oder abgezogen werden.
Transaktionen werden in einer HashMap gespeichert, damit der Aufruf m\"oglichst schnell vonstattengeht.
Der Key in der HashMap ist ein Integer, welcher sich wie folgt zusammenstellt:

\begin{align}
    HashKey &=& x \cdot 1000 + y \cdot 10 + r \\
    21.174 &=& 21 \cdot 1000 + 17 \cdot 10 + 4
\end{align}

Befindet sich nun eine Transition an der Position x = 21 und y = 17 in Richtung nach unten also dem Wert 4 so lautet der dazugeh\"orige Hash Key 21174, wie er auch in Zeile 2 berechnet wird.
Der Vorteil dieser Variante ist, dass jede Position und jede Richtung eindeutig zur\"uckgewandelt werden kann und es weniger Speicheraufwand als ein String ben\"otigt.
Zudem wird ein String als Key von der HashMap aufwendig in einen Integer umgewandelt - diesen Aufwand k\"onnen wir somit einsparen.
Als Value wird HashMap ein Objekt der Klasse Transition \"ubergeben.

\vspace{1em}
\begin{table}[!h]
    \centering
    \begin{tabular}{|c l l|}
        \hline
        \textbf{} & {Player} & {} \\
        \hline
        - & overrideStone: & int \\
        - & bomb: & int \\
        \hline
        + & getBomb(): & int \\
        \hline
    \end{tabular}
    \label{tab:uml-player}
\end{table}


\bigskip
\newpage